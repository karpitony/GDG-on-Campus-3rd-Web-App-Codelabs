# 태초 웹 - URL과 html 파일의 매칭

![image.png](attachment:ff5d2e7b-eade-4851-ad8e-f47786d4f660:image.png)

- 이때는 진짜 "웹 문서"
- URL → 파일 매칭, 진짜 문서 느낌
- 정적 웹서버로 끝
`Apache HTTP Server` 같은 정적 웹서버로 서빙만 함

아 근데 사용자마다 다른 정보를 보여주고 싶다…

아 시간에 따라 데이터가 바뀌면 좋겠다…

# WAS란 개념의 등장

![image.png](attachment:d5615745-8ba7-4f3c-bdd4-86b2c979b5cb:image.png)

- DB, 템플릿 엔진으로 구성된 서버 프레임워크들이 등장
    - `Java`, `Python`, `Ruby` 이런 언어들로 만듬
    - `django`, `Jsp`, `Rails` 등 MVC 구조로 DB + 템플릿 엔진 구조
- 데이터 베이스가 있어서 사용자마다 다른 데이터 제공 가능.
- 웹문서에서 점점 어플리케이션으로 변해감
- 지금의 프론트에 해당하는 View는 JQuery + 템플릿 문법 떡칠…
    - 서버에서 HTML을 만드는 서버 사이드 렌더링… 데이터 업데이트마다 새로고침이 필요함.
    - 새로고침은 화면이 하얘지고, 사용자들이 싫어함
    - 데이터 업데이트에 새로고침을 꼭 해야할까

# AJAX **시대 ― 웹앱으로 공식 진화**

- 기존 SSR: 데이터 바뀌면 매번 **새로고침 필수**
    
    → 사용자 경험 너무 떨어짐 → **부분 업데이트 필요**
    
- 그래서 **AJAX(Asynchronous JS and XML)** 등장
    
    → 새로고침 없이 서버에서 데이터만 받아와 UI 일부 갱신
    
    → 왜 비동기? JS는 할일이 많다.
    
    ![image.png](attachment:3751273e-01b8-41d2-9f25-53e70a07790d:image.png)
    
    스크롤, 클릭등에 이벤트 리스너 붙여야 되고, 
    버튼 눌르면 화면을 바꾸는 등 동적인 작업을 혼자 처리해야함…
    
    → 초창기엔 JSON이 아니라 **HTML 조각을 받아오는 방식**이었음
    
- jQuery **`.ajax()`**가 대세가 되면서
    
    → “웹페이지가 아니라 **웹 애플리케이션**”이 본격적으로 자리 잡음
    
- 하지만…
    - 여기저기 화면 조각을 직접 패치하다 보니 구조가 점점 복잡해지고
    - 상태가 늘어나면서 스파게티 코드
        
        → 더 체계적으로 UI와 상태를 관리하는 방식 필요
        

# React 시대 + SPA 패러다임

- 모바일 앱처럼 **부드러운 인터랙션**을 원하게 됨
- 인터랙션이 늘수록 상태(변수)도 늘어남
- 상태에 따라 자동으로 UI를 갱신하는 방식이 필요했는데
→ React가 이걸 쉽게 해주네?

```jsx
import { useState } from "react";

export default function App() {
  const [count, setCount] = useState(0);
  return (
    <div>
      <p>{count}</p>
      <button onClick={() => setCount(prev => prev + 1)}>
        Click Me!
      </button>
    </div>
  );
}

```

## SPA

**한 번 로딩한 페이지 안에서 JS로 화면을 계속 바꿔주는 방식**

→ 전체 페이지를 매번 새로고침하지 않음

→ 앱(App)처럼 부드럽고 즉각적인 UI 경험 가능

![image.png](attachment:c9ace448-2318-448c-ab6a-bae4bfaddc02:image.png)

### **💡 어떻게 동작함?**

- 서버는 하나의 HTML 파일(index.html)만 내려줌
- 이후 화면 전환(URL이 전환되는 것 포함), UI 업데이트는 **모두 JS가 담당**
- React·Vue·Svelte 등이 SPA 프레임워크
- SPA의 핵심은:
    - 모든 화면을 **JS로 작성**
    - JS가 사용자 브라우저에서 실행되며 HTML, CSS등을 생성해나감
        - SPA === CSR (Client Side Rendering)
    - 번들러(Rollup/Webpack)로 하나로 묶어
    - **`index.html`**, **`index.js`**, **`index.css`** 같은 결과물을 **CDN에 올려서 서비스**
- 경험해본 사람들은 알겠지만
    
    → 코드 변경 시마다 **재빌드가 필수**
    
    → 서버 없이도 html/css/js만 있으면 서비스 가능
    
- 웹마스터(과거 풀스택)에서 프론트와 백이 분리되면서 SPA는 더 각광
    
    → 각자 전문 분야에 집중 가능
    
    → 사용자 경험/개발자 경험 모두 상승
    

- **🔗 SPA는 사실 ‘AJAX를 잘 쓰기 위한 구조적 해답’이기도 함**
    
    과거에는 AJAX로 **부분 업데이트**는 가능했지만,
    
    여전히 “페이지 전체를 어떻게 관리하고 구성할지”에 대한 표준 구조가 없었음.
    
    → 그래서 jQuery 시절엔 화면 규모가 커지면 **스파게티 코드**가 됨
    
    → 화면 상태 관리, UI 자동 업데이트, 라우팅 등을 매번 직접 구현해야 했음
    
    SPA 프레임워크들은 이 문제를 해결함:
    
    - 라우팅을 JS에서 통합 관리
    - AJAX(Fetch)로 가져온 데이터를 상태(state)에 넣으면 UI가 자동으로 반영
    - 화면 전체를 컴포넌트 단위로 쪼개 구조적으로 관리 가능
    - 비동기 통신이 중심이 되는 웹 앱 개발을 쉽게 만듦
    
    즉 **비동기 AJAX 통신을 기반으로 동작하는 큰 규모의 웹 앱을 만들기 위해 등장한 구조적 패턴**이 SPA임.
    

# SPA 단점

- SPA는 무거움
    - 아까 다 RollUP한다 했는데 리액트 하면 리액트만 씀?
    컴포넌트 프레임워크, 라우터, 전역상태관리, 런타임 타입관리, 쿼리 등....
    와 겁나 무겁겠다...
    => 네트워크 환경에 따라 초기로딩속도가 엄청 느려질 수 있음
- 느려지면? js를 실행해야 화면에 뭐가 보이는데…
    - js 로딩될 때까지 초기 몇초동안 아무것도 안보임
- 검색봇이 SPA를 잘 인식못함 (SEO 문제)
    - 구글 검색봇은 그래도 js를 실행하나, 다른 사이트들은 html만 읽는 경우 많음
    - 구글봇도, 내 경험상 첫페이지만 잘 읽고 나머지 URL들은 찾지 못했음
    - (카더라) 사이트마다 크롤링 토큰이 있고, 리액트 같은 SPA 사이트들은 이 토큰을 많이 갉아먹음
    당신이 만든 사이트, 유명함? 유명해질려고 구글에 인덱싱 요청하는거잖음
    초기 토큰 적어서 많이 긁어가질 못함....

와 어카지?

그럼 리액트를 서버에서 돌리죠.

# SSR의 재유행

- 템플릿 엔진 시절처럼 서버에서 HTML을 만들어주는 방식
- 그럼 뭔차이임? 걍 장고 쓰실?
    - 사용자 기기에선 SPA로 동작한다는거임!
- 네트워크 탭을 열어보면 알겠지만, SSR 프레임워크의 특징은 "첫페이지 사전 렌더링"인거임
- 상태 많은곳에 써야 하니 useState, 이벤트 리스너 등이 붙어야 하는데 이걸 위해 js 청크를 같이 줌
    - 건포도 - HTML
    - 물 - JS
    - 섞어서(Hydration) 동적인 웹 페이지 만듬

얘네들 특징이 페이지 이동을 특수 컴포넌트나 훅으로 처리함

왜?

새로고침 없애려고,
그렇게 이동하면 이떄는 새 html이 아니라 js 덩어리를 줌
=> 새로 매번 요청하는 검색 봇은 항상 html받아서 좋고,
=> 사용자는 화면이 부드럽게 전환되고, 상태도 많이 담을 수 있어서 좋음

- SSR 프레임워크의 특징
    - 첫 페이지는 **HTML로 사전 렌더링**
    - 이후 페이지 이동은 **SPA 방식(History API + JS 라우팅)**
        
        → 새로고침 없음
        
        → 상태 보존
        
        → 사용자 경험이 매우 부드러움
        
        → 검색봇은 항상 HTML을 받아가므로 SEO도 좋음
        

![image.png](attachment:fc90fdff-0cd7-4bc6-8792-dd52509ed807:image.png)

![image.png](attachment:a567aee7-0ee1-4b3f-9532-5806129b466e:image.png)

![image.png](attachment:aae7c7ff-a105-4cef-ad71-a8875e648531:image.png)

![image.png](attachment:647c8a82-e435-4735-b080-3a238cca8c58:image.png)

첫페이지는 HTML + JS

페이지 이동시 JS + RSC (초기 레이아웃이나 데이터를 JSON구조로 직렬화해놓은 것)

RSC 궁금하면 이거 참고하시면 좋습니다!

https://youtu.be/XdiMjKSCOfc

- 아 근데 서버에서 html을 만들고, API는 useEffect감싸서 마운트시 요청? 이럴거면 SSR을 왜해?
- 보통 데이터는 검색봇이 가져가야 하고, 데이터가 채워져야 SEO에 좋은 경우
→ SSR 과정중에 fetch후 데이터를 채워서 html을 만듬
→ fetch 올때까지 기다리니까 이거 느리잖아?

이러면 첫페이지 로딩 시간이 좀 길어질수도?

## Streaming SSR (React 18+)

![image.png](attachment:4285ecf4-2881-4a8a-b4bb-97a3d9a63747:image.png)

- 첫 HTML을 완전히 채워서 보내는 게 아니라
    
    → **보낼 수 있는 부분만 먼저 보내고**
    
    → 나머지는 프론트 서버에서 fetch 받을때마다 클라이언트로 스트리밍으로 채워 넣는 방식
    

![image.png](attachment:a9b9105f-ec78-4737-b315-fcf838b5c128:image.png)

```jsx
export default function Page() {
  return (
    <Suspense fallback={<p>로딩중…</p>}>
      <SlowComponent />
    </Suspense>
  );
}

```

- placeholder를 먼저 그려놓고
- 나중에 서버에서 데이터를 받아오는 즉시
    
    → 그 부분만 채워넣음
    

**주의사항**

- 모든 걸 Suspense로 감싸면 초기 HTML이 비어서 **SEO가 망함**
    
    → 개발자가 “이 부분은 SEO에 필요하다/필요 없다”를 판단하며 적절히 Suspense 사용해야 함
    
- 구글봇은 이정도는 잘 처리하지만, 네이버 봇등 다른 봇은 미지수….

# 복습하기

https://www.instagram.com/p/DRhRAlnCQ2n/

- 얼마전에 올라온 건데 딱 CSR → SSR 전환 얘기 다루고 있으니 한번 풀어보면 재밌을거 같아요 ^^

# 잡설 - 프론트 변화 따라가기

![image.png](attachment:33f3c692-7876-4622-b1ba-a36a9ad73dd4:image.png)

- 앵귤러는 혼자 노니까 빼고,
- 리액트
    - 리액트 팀 반쯤 Vercel에 점령
    - 대표적인 메타 프레임워크(프레임워크의 프레임워크) Next.js - Vercel꺼
- 뷰
    - Nuxt가 Vercel 소유로 전환
- 스벨트
    - 개발팀이 Vercel에 합류 (독자적으로 활동하긴 하나…)

프론트 개발자면 좋든싫든 앞으로 몇년이상 버셀과 함께할 운명…

그럼 버셀이 젤 많이 쥐고 흔드는 Next.js의 변화를 따라가야 좋지 않을까…

<aside>
💡 약간의 기술질문 대답 팁?
Q: 왜 Next.js 썼어요?
A: 리액트에 SSR을 더해서 SEO를 챙기기 위해서요 (X)
A: Next.js가 제공해주는 프레임워크적인 측면이 협업과 구조화에 도움이 되어서 사용했습니다.
(훨씬 좋음)
생 리액트도 SSR + Hydration이 가능하기 때문에…

</aside>